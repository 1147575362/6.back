1、运算符重载
    所谓运算符重载，就是给已有的运算符添加新功能，使得这些运算符能适用于类类型。
    在C++中，运算符是用函数实现的，所以运算符重载的本质就是函数重载。

    运算符与运算符函数的对应关系：
        1、运算符号 对应 函数名 ，函数名由 operator加运算符组成
            +  =>  operator+
            << => operator<<
            *  => operator*
        2、操作数 对应 函数参数
            单目运算符函数如果是全局函数，对应的函数就有一个参数，如果是非静态成员函数，则没有参数
            双目运算符函数如查是全局函数，对应的函数就有两个参数，如果是非静态成员函数，则只有一个参数
            但是，有些情况例外：
                后自增与后自减如果是全局函数，有两个参数，如果是非静态成员函数，有一个参数。

        3、运算结果 对应 函数的返回值

        4、运算过程 对应 函数体 

    运算符函数写好后，一般由编译器自动调用，但是也可以像普通函数一样的调用。
    例： 
    class Demo 
    {
    public:
        Demo operator-(Demo d2) 
        {
            // 相减的过程
        }
    private:
    };

    // 全局函数
    Demo operator+(Demo d1, Demo d2)
    {
        // 相加的过程
    }

    int main()
    {
        Demo d1, d2;
        Demo d3 = d1 + d2; // 自动调用 operator+
        Demo d4 = operator+(d1, d2); // 像普通函数一样的调用

        Demo d5 = d1 - d2;
        Demo d6 = d1.operator-(d2);
    }


    练习： 
        自定义一个类型，添加运算符功能，如+ - ==  >  < 

        Complex c1(1,2);
        c1 + 1;
        c1 + 1.1;
        1 + c1;
        1.1 + c1;

        a < b;
        b < a;
        !(a < b ) and !(b < a) 

    输入输出运算符：
        1、IO流对象不能拷贝
        2、输入输出运算符只能重载为全局函数


    赋值运算符
        对象的拷贝
            是用一个已经存在的对象初始化一个新对象
            是用一个已经存在的赋值给另一个已存在对象

        例： 
            Complex c1(1,2);
            Complex c2 = c1; // 拷贝构造函数

            Complex c3(3,4);
            c3 = c1;        // 拷贝赋值运算符

        如果一个类中没有显式的定义赋值运算符函数，编译器会自动生成，执行浅拷贝

        赋值运算符只能重载为类的非静态成员函数，一般形式如下：
            类名& operator=(const 类名&);


        对象的移动
            是把一个已经存在的对象的资源转移给一个新对象
            是把一个已经存在的对象的资源转移给另一个已存在的对象
            
            移动赋值运算符函数一般如下：
                类名& operator=(类名&&);
        
        练习： 
            定义一个类型，成员为一个char*, 在构造函数中申请资源
            请实现该类的拷贝构造函数 和 拷贝赋值运算符函数 和 析构函数。

            请给单链表类型 添加 拷贝构造函数、拷贝赋值函数、输出函数。



    自增(减)运算符 
        即可以重载为全局函数，也可以重载为类的非静态成员函数
        前++函数的一般形式：
            类名& operator++(类名&); // 全局函数 
            或
            类名 operator++();      // 非静态成员函数

        后++函数的一般形式：
            类名& operator++(类名&, int); // 全局函数 
            或
            类名 operator++(int);       // 非静态成员函数
        注：
            后++函数参数中的int, 只占位置，不参与运算，称为占位符参数，只需要写类型,不用写形参
            --运算符与++类似。



    函数调用运算符 ()
        如果一个类重载了函数调用运算符，则该类型的对象，称为函数对象(仿函数)
        函数对象的行为类似于函数，可以调用。
        例： 
        class Demo 
        {
        public:
            void operator()() const 
            {
                cout << "this is a test function" << endl;
            }
        };
        int main()
        {
            Demo d; // d就称为函数对象
            d(); // 调用对象
        }

    匿名函数-lambda表达式
        一个 lambda表达式 表示一个可调用的代码单元，一般称为匿名函数，其本质就是一个函数对象
        格式如下：
            [捕获列表](参数列表)->返回类型{函数体}
        说明： 
            一个 lambda表达式 一般出现在函数内部，而函数中可能有局部变量
                如果 lambda表达式的函数体 需要使用它所在函数中的局部变量
                则需要在 lambda表达式的[]中进行说明，这个对所在函数的局部变量的说明，称为捕获列表
                捕获列表中如果只说明变量名，则只能对读取这些变量的值
                如果需要修改这些局部变量，则必须捕获其引用
                如果需要捕获所在函数中的所有的局部变量的值，可用 = 表示 
                如果需要捕获所在函数中的所有的局部变量的引用，可用 & 表示 
                如果不需要使用所在函数中的局部变量，中括号可为空，但不能省略。

            参数列表与一般的函数类似，但，如果不需要参数，则可以省略(), 且不能设置默认值
            返回类型一般省略，编译器会根据函数体中的return语句后的表达式，自动推导其返回类型
            函数体可为空，但大括号不能省略

        例： 
        int main()
        {
            int a = 1;
            int b = 2;
            auto f = [a, &b]
            {
                ++b;
                cout << "a = " << a << endl;
                cout << "b = " << b << endl;
            };
            f();
            // auto 在C中，表示自动变量，从C++11起，它不再表示自动变量，而是用来自动推导对象的类型
        }


自动类型转换
    例： 
        class Demo 
        {
        public:
            Demo(int x){}
            Demo& operator=(const Demo& other)
            {

            }
        };

        Demo d1;
        Demo d2;
        d1 = d2;
        d1 = 100;
    当编译器检测到不太合适的类型时，会尝试做自动转换，一般如下：
        构造函数转换
        例： 
            std::string s = "hello";
            说明： s是string类型的对象，"hello"是const char*类型的值
                即=两边的类型并不一致，编译器会自动查找string的构造函数，看其是否能接收const char*类型的值
                如果可以，则自动调用构造函数生成一个临时对象，再用该临时对象来初始化对象s
                大多数情况下，这个步骤被编译器给优化掉了，优化后的结果与以下等同：
                std::string s("hello");

            如果不希望编译器做这种隐式转换，可以用关键字explicit来修饰构造函数
        例： 
            class Demo
            {
            public:
                explicit Demo(int x) 
                {
                    cout << "单参数的构造函数" << endl;
                }
                explicit Demo(int x, int y)
                {
                    cout << "两参数的构造函数" << endl;
                }
            };
            Demo d1 = 100;          // error
            Demo d2 = {100,200};    // error
            Demo d1(100);           // ok
            Demo d2(100,200);       // ok 


        运算符转换
        例： 
            class Demo 
            {
                operator int() const
                {
                    cout << "operator int" << endl;
                    return x;
                }
                operator double() const 
                {
                    return y;
                }
            private:
                int x;
                double y;
            };

            Demo d;
            int a = d;
            double b = d;
        类型转换运算符是 一种特殊的成员函数，它负责将一个本类的对象转换成其它类型的对象，一般形式如下：
            operator 类型名() const ;
        说明： 
            1、类型名 可以是任意合法的类型名，除了void
            2、它没有返回类型，也不能有参数，应该加上const
            3、它必须是类的成员函数


最后：
    1、大多数运算符可以重载，但有些不行，如：
        .   ?:  ::  sizeof  .*

    2、以下运算符只能重载为成员函数
        =   []  ()  ->

    3、以下运算符只能重载为全局函数
        <<  >>
    
    4、只有当操作数中至少有一个自定义类型的对象时，才需要运算符重载，重载的运算符不能改变原有的语义，如操作数个数、优先级等

    5、只能重载已有运算符，不能创建新的运算符。


------------------------------------------------------------------------------------------------------
设计模式
    设计模式 是程序员经过长时间实验和总结出来的 解决特定问题 的 核心解决方案。
    上个世纪90年代，有四个程序员写一本关于设计模式的书《设计模式-可复用面向对象软件的基础》，一般称为Gof设计模式
    在Gof设计模式中，一共收录了23种经典设计模式，每一种设计模式都描述了一个经典问题的核心解决方案。
    这23种设计模式可分为三类：
        创建型模式，如单例模式、工厂模式
        结构型模式，如适配器模式、代理模式、装饰器模式
        行为型模式，如迭代器模式、观察者模式



单例模式
    保证一个类只生成一个实例，同时提供一个全局的访问点
    一般思路：
    1、不允许用户实例化对象，而是由类自身负责对象的实例化
    2、提供一个公开的静态方法，以获取这个唯一的实例

    具体：
        根据对象实例化的时机，单例可分两种：
        预先初始化(饿汉式)
            在C++中，一般使用静态成员对象来实现
            只要加载了该类型，就自动创建那个唯一的实例(对象)。
            
        延时初始化(懒汉式)  
            在C++中，当前一般使用静态局部对象来实现
            只有当第一次调用了获取实例的那个方法，才会创建这个唯一的实例。

    懒汉式示例：
    class  Singleton
    {
    public:
        int getValue() const ;
        // 公有的静态方法
        static Singleton&  getInstance()
        {
            // 静态局部对象
            static Singleton s(0);
            return s;
        }
    private:
        Singleton(int value);   // 隐藏构造函数
        Singleton(const Singleton&) = delete; // 删除拷贝构造函数
        Singleton& operator=(const Singleton&) = delete; // 删除拷贝赋值运算符

    private:
        int x;
    };

    使用：
    Singleton& s1 = Singleton::getInstance();  // 获取唯一的实例




-----------------------------------------------------------------------------------
迭代器模式
    提供一种方法顺序访问一个聚合对象中的各元素，而又不暴露它的内部实现。
    在标准C++中，迭代器模式的一般实现：
    1、把聚合对象的"遍历机制"包装成一个对象，并提供一组运算符接口，使得使用这种对象可以像普通指针一样的去遍历聚合对象
        这种对象就是所谓的迭代器
    2、每个聚合对象需要提供两个接口begin和end，用来获取首元素迭代器和尾后迭代器

    例： 
    class String 
    {
        // 其他成员函数的实现
        
        // 字符串类型的迭代器
        class Iterator
        {
        public:
            Iterator(char* p):p(p) {}
            char operator*() const 
            {
                return *p;
            }
            Iterator& operator++()
            {
                p++;
                return *this;
            }
            bool operator!=(const Iterator& rhs) const 
            {
                return p != rhs.p;
            }
            
        private:
            char* p;
        };

        Iterator begin() // 首元素迭代器
        {
            return Iterator(_s);
        }
        Iterator end()   // 尾后迭代器，最后一个元素后面那个位置
        {
            return Iterator(_s+this->size());
        }

    private:
        char *_s;
    };

    练习： 
        1、给自定义的字符串添加迭代器功能，并测试
            String s1 = "hello";
            for (auto it = s1.begin(); it != s1.end(); ++it)
            {
                cout << *it << " ";
            }
            cout << endl;
        2、给自定义的单链表添加迭代器功能，并测试
            ForwardList list;
            for (auto it = list.begin(); it != list.end(); ++it)
            {
                cout << *it << " ";
            }
            cout << endl;







