1、继承
    所谓继承，指的是在已有类型的基础上，创建新的类型，新的类型继承(拥有)已有类所有的特性。
    继承可实现代码复用，减少代码冗余，提高开发效率。
    继承主要用于描述那些非常相似只有细节差异的类型之间的关系。

    通过继承联系在一起的这些类型，构成层次关系
    位于层次关系中根部的类型，称为基础类，简称基类(Basic Class), 也可称为父类
    层次关系中其它的类，都是以基类为基础派生出来的新类型，这些类称为派生类(Derived Class)，也可称为子类

    基类负责定义在层次关系中所有类的   共同特性。
    派生类继承基类中的共性，并添加新的特性。

    C++中的继承语法格式：
    class 派生类名: 继承方式 基类名1, ...,  继承方式 基类名n 
    {
        定义派生类新增的成员
    };

    根据基类个数，继承可分为：
        单(一)继承: 只有一个基类
        多(重)继承：两个或以上的基类


    继承方式：
        public      公有继承
        private     私有继承
        protected   保护继承
    注：
        继承方式决定了基类中的成员 在派生类内部和外部的访问权限。
        struct默认情况下，使用公有继承
        class默认情况下，使用私有继承

    公有继承规则：
        基类的公有成员，通过公有继承，成为派生类自己的公有成员。
        基类的私有成员，通过公有继承，成为派生类的一部分，但是派生类不可直接访问(也称为不可访问的成员)
        基类的保护成员，通过公有继承，成员为派生类自己的保护成员。
        保护成员：
            成员函数可直接访问，友元直接可访问，派生类直接可访问，其他情况不能访问

    私有继承规则：
        基类的公有成员，通过私有继承，成为派生类自己的私有成员。
        基类的私有成员，通过私有继承，成为派生类的一部分，但是派生类不可直接访问(也称为不可访问的成员)
        基类的保护成员，通过私有继承，成员为派生类自己的私有成员。

    保护继承规则：
        基类的公有成员，通过保护继承，成为派生类自己的保护成员。
        基类的私有成员，通过保护继承，成为派生类的一部分，但是派生类不可直接访问(也称为不可访问的成员)
        基类的保护成员，通过保护继承，成员为派生类自己的保护成员。

    例： 
        class Student 
        {
        public:
            void study() {}
            void speak() {}
            void sleep() {}
            void play()  {}
        private:
            int id;
            string name;
            int age;
        };

        class CollageStudent: Student
        {
        private:
            string major;
        public:
           
        };

        class Pupil: Student
        {
            
        };

2、继承中的构造与析构
    构造函数与析构函数不能继承。(c++11中新增了继承构造函数的方法，但一般不用)
    拷贝构造、拷贝赋值这些与资源分配相关的函数都是不可继承的。
    基类的静态成员由同类型(基类相同)的对象共享，不算继承。

    如果基类有默认构造函数，当实例化派生类对象时，会自动调用基类的默认构造函数
    如果基类没有默认构造函数，或需要调用基类的其它构造函数，则只能在派生类构造函数的初始化列表中，显式的调用基类的构造函数
    一般如下：
        派生类构造函数名(参数列表):基类的构造函数(参数列表) {}

    当实例化派生类对象时，先调用基类的构造函数，再调用派生类自己的构造函数
    当派生类对象销毁时，先调用派生类的析构函数，再调用基类的析构函数

    练习：
    派生类可以新增成员，增加的成员可以是基础类型的，也可以是自定义类型的
    如果是类类型的成员对象，则在初始化时，需要调用它的构造函数
    
    写代码，验证成员对象的构造函数的调用时机及成员对象的析构函数调用时机

    例： 
    class Other
    {
    public:
        Other(int x) { cout << "成员对象的构造函数" << endl;}
    };
    class Base
    {
    public:
        Base(int y) {cout << "基类的构造函数" << endl;}
    };
    class Derived: Base
    {
    public:
        Derived(int x,int y, int z): o(x), Base(y), z(z){cout << "派生类自己的构造函数" << endl;}
    private:
        Other o; // 成员对象
        int z;
    };

    结论：
        基类的构造函数
        成员对象的构造函数
        派生类自己的构造函数 
        析构函数的调用顺序与构造函数相反。


3、继承中的同名成员
    派生类中可以在基类的基础上增加新的成员
    这些新的成员可以与基类的成员同名
    但当用派生类对象去访问这些同名成员时，基类的同名成员被隐藏
    如果需要访问那些被隐藏的成员，只需要指定作用域即可,例： 
        d.Base::print(100);

    如果被隐藏的是成员函数，则称这种现象为 函数隐藏
    函数隐藏只要求函数名相同，与返回类型与参数列表无关。

    例： 
    class Base
    {
    public:
        void print() const 
        {
            cout << "x = " << x << endl;
        }
    private:
        int x=1;
    };
    class Derived: public Base
    {
    public:
        void print() const 
        {
            cout << "x = " << x << endl;
        }
    private:
        int x=2;
    };

    Derived d;
    d.print();
    

4、派生类与基类的关系
    公有派生类继承了基类所有的特性，也就是说基类对象具有的功能，公有派生类对象都有
    那么当需要一个基类对象时，就可以使用公有派生类对象来代替。
    具体如下：
        1、可以用派生类对象来初始化基类对象
            Derived d;
            Base b(d);
        2、可以用派生类对象给基类对象赋值
            Base b2;
            b2 = d;
        3、基类指针可以指向任意派生类对象
            void foo(Base* p);
            foo(&d);
        4、基类引用可以绑定到任意派生类对象
            Base& r = d;

    但是，用派生类初始化的基类对象/指针/引用，都只能访问派生类中从基类继承来的部分，无法访问派生类新增加的部分。

    公有派生类与基类的这种关系，一般描述为： is-a的关系

    练习： 
        写代码验证以上机制。



5、多重继承 
    所谓多重继承，指一个派生类有多个基类的情况，派生类继承它所有基类的特性。

    多重继承中的二义性问题
    例： 
    class Base1
    {
    public:
        void print() const {}
    };
    class Base2 
    {
    public:
        void print() const {}
    };

    class Derived: public Base1, public Base2
    {};

    Derived d;
    d.print(); // 语法错误 ambiguous

    解决办法：
        添加作用域即可
        d.Base1::print();
        或
        d.Base2::print();

    
    菱形继承/钻石继承
    例： 
    class A {};
    class B: public A {};
    class C: public A {};
    class D: public B, public C {}
    菱形继承中可能存在的问题：
        1、二义性问题
        2、顶层A类中的成员，到达底层D类中时，可能出现多份

    解决办法：虚继承
        所谓虚继承，指在直接基类B和C继承间接基类A时，在继承方式后面(或前面)加上关键字 virtual
        被虚继承的A，称为虚基类
        虚基类A中的成员会被它虚继承所产生的派生类B 和 C所共享，最底层的派生类D中只保留虚基类A的一份成员。

    例： 
    class A {}; // 虚基类
    class B: virtual public A {}; // 虚继承 
    class C: virtual public A {}; // 虚继承 
    class D: public B, public C {}

    一般情况下，虚基类A的成员，存放在D类对象成员的后面，D类对象的内存布局大概如下：
        从B类继承来的成员(包括虚基类指针)
        从C类继承来的成员(包括虚基类指针)
        D类自己新增的成员
        虚基类A的成员
    为了能够通过B和C去访问虚基类的成员，需要记录虚基类A的成员距离B和C有多远，即偏移量
    这个偏移量，单独存放，存放偏移量的这个数据结构，称为虚基类表
    为了能够得到这个偏移量，需要记录虚基类表的地址，即需要一个指针来指向虚基类表，称为虚(基类)指针
    每个使用了虚继承的类都会有一个虚基类指针
    当计算派生类D的大小时，需要考虑这个虚基类指针，在32位平台，一个指针4字节，在64位平台，一个指针8字节，同时需要还考虑字节对齐。

    同时，底层派生类对象在构造时，必须先调用虚基类A的构造函数，再调用B和C的构造函数，然后调用D的成员对象的构造函数，最后调用D自己的构造函数
    B和C就不需要再初始化A中的成员了。


    










多态
    所谓多态，指不同的对象，收到相同的消息，产生不同的行为。
    说明：
        不同的对象，是指同类族中的不同类型的对象
        收到相同的消息，是指调用这些不同对象的相同的成员函数
        产生不同的行为，指这些相同的函数定义不同

    多态实现了接口重用
    多态在一定程序上忽略了那些相似类型的差异，以统一的方式使用它们。

    C++中的多态，可分两种：
        编译时多态(静态多态、静态绑定、静态联编)
            当调用函数时，编译器在编译阶段就能决定了具体要调用哪个函数
            实现方式：重载(函数重载、运算符重载)、模板
        例： 
        class Demo 
        {
        public:
            void foo() {}
            void foo(int x){}
        };
        Demo d1;
        d1.foo();
        Demo d2;
        d2.foo(100);
        运行时多态(动态多态、动态绑定、动态联编)
            当调用函数时，编译器在编译阶段无法决定具体要调用的是哪个函数
            实现方式： 虚函数

虚函数 virtual function
    用关键字virtual说明的函数，称为虚函数, 一般如下： 
        virtual 返回类型 函数名(参数列表);

    如果一个函数被说明为虚函数，表示允许它的派生类重新定义该函数(称为函数重写，也叫函数覆盖)
    如果用指针或引用来调用虚函数，则会发生动态绑定，产生多态现象。
    动态绑定： 
        一般来说，指针类型应该与它指向对象的类型相匹配，但有如下例外：
            1、const指针可以指向const对象，也可以指向非const对象
                int a = 100;
                const int* p = &a;
            2、基类指针可以指向派生类对象
                Base* p = new Derived;
            当使用基类指针或引用时，可能指向基类对象，也可能指向派生类对象，编译器在编译时，无法确定
            只有当程序执行时，才能确定指针的指向，再根据指针的指向决定调用哪个虚函数。

    如果在派生类中定义与基类虚函数原型(返回类型、函数名、参数列表)完成相同的函数，则派生类中的该函数自动成为 虚函数。
    例： 
    class Base
    {
    public:
        virtual void show() // 基类定义的虚函数
        {
            cout << "hello" << endl;
        }
    };

    class Derived: public Base 
    {
    public:
        void show() // 函数原型与基类虚函数相同，自动成为虚函数
        {
            cout << "world" << endl;
        }
    };        

    void foo(Base* p)
    {
        p->show(); // 编译时，编译器无法确定，这里调用的是哪个虚函数
    }

    C++11中引入了两个关键字
        override
            用于说明派生类的某个函数是重写了基类的虚函数
        final
            用于说明某个虚函数不允许重写
            用于说明某个类不能被继承
        例： 
            class Demo final // Demo类不能被继承
            {};
            class Derived: public Demo  // error
            {}

    练习： 
        定义一个学生基类，描述学生共性
        学生类应该提供学习的方法： study
        不同的学生，学习的内容并不相同

        使用基类指针或引用体现学习的多态现象

        例： 
        class Student
        {
        public:
            void study() {}
            ...
        };

        void foo(Student* ps)
        {
            ps->study(); // 如果ps指向大学生对象，则显示大学生学习的内容，如果ps指向小学生对象，则显示小学生学习的内容
        }



纯虚函数与抽象类
    在设计基类时，有些虚函数不应该提供定义，如学生类的study函数，而是要求派生类必须自己定义它的行为
    此时，可以把该函数说明为 纯虚函数： 
        virtual 返回类型  函数名(参数列表) = 0;
    
    如果一个类中包含纯虚函数，则称这种类为 抽象类型。
    抽象类型无法实例化对象。

    注： 
        如果派生类没有重写纯虚函数，则纯虚函数一样会被派生类继承，同样称为抽象类，无法实例化对象。


    
虚析构函数
    正常情况下，当派生类对象销毁时，会先调用派生类自己的析构函数，再自动调用基类的析构函数
    然而，如果是用基类指针指向一个new出来的派生类对象，当不再使用该对象时，应该使用delete释放这个new出来的对象
    例： 
        Base* p = new Derived;
        ...
        delete p;
    此时，只会调用基类的析构函数，而不会调用派生类的析构函数，就有可能造成资源泄漏。
    解决方法：
        把基类的析构函数设置为 虚函数。
    建议：
        基类的析构函数应该设置为虚函数。



虚函数与默认参数
    虚函数可以没有参数，也可以有参数，有参数就意味着可以重载
    也意味着可以设置默认值
    例： 
    class Base 
    {
    public:
        virtual void foo(int x, int y) {}
        virtual void foo(int x=1) {}
    };
    如果基类的虚函数设置了默认值，则派生类重写的虚函数，可以不设置默认值，也可以设置不同的默认值
    但是发生动态绑定时，编译器在编译阶段就决定了只用基类设置的默认值。
    class Derived
    {
    public:
        void foo(int x=2) {}
    };

    void bar(Base* p)
    {
        p->foo(); // 此时，使用的是基类设置的默认值
    }


动态类型转换 dynamic_cast
    用于多态类型之间 向下类型 转换(包含虚函数的类型，称为多态类型)
    如果转换成功，返回对象的地址，否则 返回空。
    例： 
    class Base 
    {
    public:
        virtual void foo() {}
    };

    class Derived: public Base
    {

    };

    int main()
    {
        Base* p1 = new Derived;
        Derived* p2 = dynamic_cast<Derived*>(p1);
        if (p2 != nullptr)
        {
            cout << "转换成功" << endl;
        }
    }

    使用示例：
        int main(int argc, char const *argv[])
        {
            Rect r;
            Circle c;

            // 把派生类对象的地址，放到一个数组中，进行统一处理
            Shape* arr[2] = {&r, &c};

            for (int i = 0; i < 2; i++)
            {
                // 把数组中的某个元素转成 Circle*, 判断其是否是指向圆对象的指针
                Circle* pc = dynamic_cast<Circle*>(arr[i]);
                if (pc != nullptr)
                {
                    cout << pc->getPI() << endl; // 如果是，则调用圆类新增加的方法
                }
                // 获取所有对象的面积
                get_share_area(arr[i]);
            }

            return 0;
        }



虚函数的调用过程
例： 
class Demo 
{
public:
    virtual void foo() 
    {
        cout << "hello" << endl;
    }
    virtual void bar() 
    {
        cout << "world" << endl;
    }
};


    void foo(Demo* p)
    {
        p->foo();
    }
    Demo* p = new Demo;
    foo(p);

    如果一个类包含虚函数，那么编译器会自动为该类维护一个 虚函数表(vtabl)
    该表中记录了该类所有的虚函数的地址
    当用指针或引用调用虚函数时，编译器会把对虚函数的调用，转换成虚函数表的索引。

    当实例化对象时，编译器会自动把该类的虚函数表的首地址(虚指针vptr)插入到对象空间中。

    当程序执行时，首先从对象空间中找到虚函数表的地址(即虚指针), 再根据虚指针找到虚函数表，
        再根据编译时记录的虚函数的索引，从虚函数表中找到虚函数的地址
        最后根据虚函数的地址，去调用虚函数。

    如果派生类重写了基类的某个虚函数，则派生类的虚函数表中，
        记录的就是那个重写的虚函数的地址，而不再是继承来的那个虚函数的地址

    所以，一个包含虚函数的类型的对象，即使没有任何成员变量，对象空间也会有一个虚指针。

