――――――――――――day1――――――――――
QT的应用和优点
1.QT应用在linux桌面环境、谷歌地图和WPS中。
2.QT跨平台；
3.一定程度上简化了内存回收机制，只要派生至QProject下的对象树，当窗口关闭时树上的对象都会被释放掉。
4.可以进行嵌入式开发。

在QT中创建对象的时候会提供一个parents对象指针，当创建一个QObject对象时，可以提供一个它的父对象，当父对象析构时，这个列表中的所有对象也会被析构。
QWidget是能够在屏幕上显示一切组件的父类，其继承自QObject，因此也继承了这种对象树的关系。
总结：
QT的对象树一定程度简化了内存回收机制。
当常见的对象指定的父亲是由QObject或者Object派生的类的时候，这个对象被加载到对象树上，当窗口关闭的时候，树上的对象也都会被释放掉。

点击按钮效果
用到connect函数:connect(信号发送者，&作用域::发送的信号，信号的接收者，&作用域::处理的槽函数) 


自定义信号槽
信号函数signals:
    1.返回值必须为void
    2.可以有参数，可以重载
    3.只要定义，不需要实现
	
信号槽函数public slots:
	1.返回值必须为void
    2.可以有参数，可以重载  
    3.需要定义，需要实现	4.自定义槽函数可以写成全局函数或者public作用域下或者lambda表达式。
	
如我自己写的工程2为例：
老师写了hungry信号函数，学生学了打印文本的信号槽函数，将其填入connect中，接着要在widget.hpp里声明一个触发这个hungry信号的函数endclass，在widget.cpp里定义endclass，函数体内写emit this->实例->hungry();再在widget构造函数中调用这个触发函数即可完成打印。

自定义信号槽并且重载
分别把信号函数和信号槽函数写个参数不同的重载，然后再widget.cpp的构造函数处写两个函数指针，分别指向带参的信号函数和信号槽函数，再在connect里填上这两个函数指针。
函数指针写法：(作用域::*自定指针名字)(参数列表) = &作用域::指向的函数名；

QString转成char*：
foodname.toUtf8().data();	//先转成QByteArray再转成char*


lambda表达式
写法[](){}
[]不能省略，用于捕获局部变量，=是指捕获可见范围内的所有局部变量，是值传递方式；&和=相似，只不过是引用传递的方式；若是=,&a则是除了a是引用，其他都以值传递；
()可以省略，是自定义变量；
{}是函数体；
这一套写下来是定义，若要调用则在后面加个括号[](){}
如果在connect里写lambda，第三个参数的this可以省略。
mutable关键字：可以修改值传递进来的拷贝
还可以用->加返回值
如[]() mutable ->int{return 1000;};


―――――――――――day2―――――――――――――
菜单栏、状态栏、中心部件最多只能有一个，工具栏、铆接窗口可以有多个。
菜单栏、状态栏这两个创建都不需要new，都有各自的方法自动挂在到对象树上，且只能用setMenuBar/setStatusBar设置到窗口中；
工具栏、铆接窗口创建都需要new，且只能用addToolBar/addDockWidget放置到窗口中。
中心部件较为特殊，其用setCenTralWidget放置窗口，但却是用new创建部件。

或者直接图形编辑，在创建项目时打上Generate form的勾，在.ui设计里直接图形编辑。
若要添加图片资源，则新建工程，在Qt一栏选上Qt Resource File，命名为res，添加到工程里，（这里注意要右键res.qrc选中Open  Editor才能打开），在里面添加前缀/，将图片文件夹放到工程目录下，再add files，全选图片加进来。



―――――――――――day3―――――――――――――
 对话框有两种分类，
 非模态对话框：可以对其他窗口进行操作；创建在堆区，需要new出来，要用show()来显示。
 模态对话框：不可以对其他窗口进行操作。创建在栈区，即不需要new出来，直接QDialog dlg(this); dlg.exec()创建，exe会阻塞。
 对话框创建：
 用QDialog创建一个dlg对象，dlg->exec()为模态对话框，dlg->show()为非模态对话框。
 
 ―――――――――――day4―――――――――――――
 int转QString：QString::num(18);
 生成exe的步骤：
 1.在QTcreator中左下角调成Release模式
 2.在左侧栏的项目里的Build directory中设置一个单独的路径用于存放release工程文件
 3.点击运行 4.再在其他地方新建一个Demo文件夹，在上面的路径中将exe文件复制进去
 5.打开版本对应的QT黑底程序，输入：
	1)cd Demo的路径
	2)cd bin
	3)windeployqt Demo的路径
6.OK

―――――――――――day4―――――――――――――
在QT中，若输入一个接口函数()没有提示要填什么参数，一般就是没有加相应的头文件。
标签里面可以放图片、动图。
图片都叫Pixmap，而不是picture。
动图都叫movie，但要movie->start才能播放。
资源文件路径":/Image/xxx.png“
若要查某个组件的信号，在此组件名前+Q搜索signals。找到后若没有signal则在父类找。若有重载则要用函数指针。

―――――――――――day5―――――――――――――
在QT中，若要做成例如C输出的printf("x = %d, y = %d",x, y)的效果，如下：
QString str = QString("x = %1, y = %2 ").arg(x, y);
若要对函数的实参列表自动补全，在函数名后输入)即可。

关于鼠标移动
ev.button()只负责单按键判断，返回一个十六进制的宏，用==来判断是否按下左键，如if(ev->button() == Qt::LeftButton)
ev.buttons()负责躲暗箭的判断，其可以按十六进制的1、2、4、8来与上多种按键组合，从而进行多按键判断。判断是否同时按下左右键则为：
if(ev->buttons() & (Qt::RightButton) && (ev->buttons() & Qt::LeftButton)) 

QT中所有事件都是以event结尾的 如mousepressevent、timerevent且以小写字母开头