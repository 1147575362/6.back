# OS





# CC





# CN





# C++

## 引用和指针的区别是？

1. 引用在初始化的时候必须绑定一个对象，绑定之后不能再成为其他对象的别名；而指针在创建的时候可以无需指向任何对象成为野指针，并且可以随时转移指向的对象在使用指针前必须进行判空操作。
2. 引用主要用于函数传参和函数返回，使用引用更加安全，效率更高，可使代码更加简洁。
3. 引用的大小是对象的大小，而指针的大小与平台有关，32位4B，64位8B。

## const与指针、引用之间的关联

有一个规则可以很好的区分const是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号（\*），**如果const出现在线的左边，指针指向的数据为常量**；**如果const出现在右边，指针本身为常量。**而引用本身与天俱来就是常量，即不可以改变指向。

1. const int* p=&i是？	定义了一个常量指针，告诉编译器*p是一个常量，不能将其作为左值。
2. int* const p = &i是？  定义了一个指针常量，告诉编译器p是常量，不能作为左值进行赋值操作，但允许对指向的对象进行修改。
3. const int* const p=&i是？  p和*p都是常量，他们都不能作为左值进行操作。

## 四种类型转换方式？

1. static_cast<目标类型>(表达式)	用于int和char、double、enum之间的转换、void*和其他指针的转换、基类和派生类的向下转换。
2. const_cast<目标类型>(表达式)	用于移除指针或者引用的const属性。
3. reinterpret_cast<目标类型>(表达式)	用于整数和指针类型的转换、任意类型的转换。
4. dynamic_cast<目标类型>(表达式)	用于多态类型向下的转换，如将Base*类型的指针转成Derived*类型的指针。

## C、C++中内存空间的分类

1. 栈区：存放非静态的局部变量，且函数调用时用于保存现场、恢复现场。其分配和释放由编译器自动控制。
2. 堆区：用于存放程序员手动malloc或new出来的动态空间，需要手动释放。因为可申请的堆区大小理论上为虚拟内存的大小，所以每个进程所拥有的堆区大小远远大于栈区大小。
3. .bss段：用于存放已初始化的全局变量、静态变量。
4. .data(数据)段：用于存放程序可执行代码、只读的常数变量。

## new和malloc的区别

1. 属性不同。new/delete需要编译器支持，malloc需要库函数<stdlib.h>的支持。
2. 参数不同。使用new不需要显式指定分配空间的大小，编译器可以通过类型进行计算；而用malloc需要指定空间大小。
3. 返回类型不同。new分配成功返回的是对象类型的指针，类型严格与对象匹配，所以new是类型安全的操作符；malloc分配成功返回的是void*，需要通过强转成我们需要的类型。而new分配失败时会抛出异常，malloc分配失败返回null。
4. new会调用对象的构造函数、析构函数。
5. new/delete允许重载，malloc不允许重载。

## 拷贝构造函数

拷贝构造函数的调用时机：

1. 用一个已经存在的对象初始化另一个对象时，如Demo d2(d1)、Demo d2 = d1。
2. 将一个对象以值的方式传递给函数。
3. 从函数中返回一个对象的值（若从函数中返回一个局部变量的值，则编译器可能会对其优化，省略拷贝构造函数的调用）。

深拷贝与浅拷贝：

1. 浅拷贝：如果一个类拥有资源，编译器对其拷贝时没有重新分配空间，而是两个对象共享了同一份资源，称其为浅拷贝。
2. 深拷贝：如果一个类拥有资源，资源重新分配，称其为深拷贝。

阻止拷贝：自己写一个拷贝构造函数，丢到private里。

## 右值引用与对象的移动

右值引用是指只能绑定到右值的引用，写法是&&，通过右值引用可以将一个对象的资源转移到另一个对象中。而标准库中有一个move()函数，其能够返回对象的右值引用，完成对象的移动。

## explicit关键字

是用来防止编译器进行隐式类型转换。这种隐式类型转换是指=号两边的类型不一致时，编译器会自动查找这个对象的构造函数，看其是否能够接收这个类型的右值，若能够则自动调用构造函数创建一个临时对象，再用这个临时对象初始化对象s。

## 重载规则

1. 不允许重载的运算符：带点的、sizeof
2. 只允许重载为**成员函数**的运算符：[]、()、->、=
3. 只能重载为**全局函数**的运算符：<< 、>>

## 设计模式

是程序员经过长时间实验和总结出来的 解决特定问题的核心解决方案。

我了解的设计模式有两种：**单例模式和迭代器模式。**

1. 单例模式：只允许生成一个实例，同时提供一个全局的访问点。做法是写一个共有的静态访问方法，在里面创建实例并返回此实例；将构造函数写进私有里。
2. 迭代器模式：顺序访问容器各个元素的一种方法，隐藏容器的内部实现，通过迭代器对外的接口操作指针去从而访问容器。 具体实现为：在该容器内部实现一个iterator类，内部成员函数重载*、!=、++用于实现解引用和for循环遍历；begin和end函数指向容器的第一个元素和最后一个元素的后面一个；成员变量为指针。

## 虚继承

解决菱形继承的二义性问题。菱形继承情况下，顶层的A基类的成员到达底层D时，可能出现多份，出现ambiguous。此时在B\C中使用虚继承，则A成为虚基类，B\C使用共享的A基类的资源，最底层的D也只会保留一份资源。 

    一般情况下，虚基类A的成员，存放在D类对象成员的后面，D类对象的内存布局大概如下：
            从B类继承来的成员(包括虚基类指针)
            从C类继承来的成员(包括虚基类指针)
            D类自己新增的成员
            虚基类A的成员
        为了能够通过B和C去访问虚基类的成员，需要记录虚基类A的成员距离B和C有多远，即偏移量
        这个偏移量，单独存放，存放偏移量的这个数据结构，称为虚基类表
        为了能够得到这个偏移量，需要记录虚基类表的地址，即需要一个指针来指向虚基类表，称为虚(基类)指针
        每个使用了虚继承的类都会有一个虚基类指针
        当计算派生类D的大小时，需要考虑这个虚基类指针，在32位平台，一个指针4字节，在64位平台，一个指针8字节，同时需要还考虑字节对齐。
    
        同时，底层派生类对象在构造时，必须先调用虚基类A的构造函数，再调用B和C的构造函数，然后调用D的成员对象的构造函数，最后调用D自己的构造函数
        B和C就不需要再初始化A中的成员了。
## 多态什么意思？

指不同的对象收到相同的消息，产生不同的行为。

静态多态(静态绑定、静态联编)：如函数重载、运算符重载、模板；

运行时多态(动态多态、动态绑定)：如**虚函数**。

如果一个函数被说明为虚函数，表示允许它的派生类重新定义该函数（称为函数重写，也叫函数覆盖）。如果用指针或引用来调用虚函数，则会发生动态绑定，产生多态现象。

## STL

### STL是什么？

STL名为Standard Templete Library（动态模板库），里面由容器、算法、迭代器等组件组成。

### 有哪些典型的顺序容器？

有array数组、vector向量。

array详解：array是一个封装固定大小的容器，可以用at和[]访问和修改其中的元素，其中at会做越界检查。

vector详解：vector是一个封装动态数组的顺序容器，其容量大小可以动态变化，size()和capacity()可以分别得出元素个数和空间容量。通过reserve()可以预定指定大小空间，通过shrink_to_fit()可以收缩空闲空间。除了emplace()，其他增加元素功能的成员函数都可以扩容空间，扩容方案是翻倍。  

### 有哪些典型的关联容器？

有set、map。

set详解：set是一个集合的数据结构，只存储key键，且存进去的key不重复，按序排列，可以用set去重。

map详解：map是一个字典的数据结构，底层原理用的红黑树，查找时间复杂度为O(logn)。其数据以键值对的形式存入，使用pair类型表示键值对，键位first，值为second。map自动对其中的元素按键从小到大排序，且键唯一，不可更改。

### 有哪些典型的容器适配器？

deque双端队列、forward_list单向链表、list双向链表。

deque双端队列是一个有下标顺序的容器，允许在首位两端快速插入删除。

链表没有下标，共有的操作是合并、逆转链表、删除连续重复的元素、对元素进行排序。



# Others